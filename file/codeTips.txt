1   两数之和 -- 容易
    给定一个整数数组和一个目标值，找出数组中和为目标值的两个数，你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。
    示例: 给定 nums = [2, 7, 11, 15], target = 9
        因为 nums[0] + nums[1] = 2 + 7 = 9
        所以返回 [0, 1]

2   两数相加 -- 中等
    给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。
    你可以假设除了数字 0 之外，这两个数字都不会以零开头。
    示例：
    输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
    输出：7 -> 0 -> 8
    原因：342 + 465 = 807

3   无重复字符的最长子串 -- 中等
    给定一个字符串，找出不含有重复字符的最长子串的长度。
        示例 1:
        输入: "abcabcbb"
        输出: 3
        解释: 无重复字符的最长子串是 "abc"，其长度为 3。

        示例 2:
        输入: "bbbbb"
        输出: 1
        解释: 无重复字符的最长子串是 "b"，其长度为 1。

        示例 3:
        输入: "pwwkew"
        输出: 3
        解释: 无重复字符的最长子串是 "wke"，其长度为 3。
             请注意，答案必须是一个子串，"pwke" 是一个子序列 而不是子串。

4   两个排序数组的中位数 -- 困难
    给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。
    请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。
    你可以假设 nums1 和 nums2 不同时为空。
        示例 1:
        nums1 = [1, 3]
        nums2 = [2]
        中位数是 2.0

        示例 2:
        nums1 = [1, 2]
        nums2 = [3, 4]
        中位数是 (2 + 3)/2 = 2.5

5   最长回文子串 -- 中等
    给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。
        示例 1：
        输入: "babad"
        输出: "bab"
        注意: "aba"也是一个有效答案。

        示例 2：
        输入: "cbbd"
        输出: "bb"

6   Z字形变换 -- 中等
    将字符串 "PAYPALISHIRING" 以Z字形排列成给定的行数：
    P   A   H   N
    A P L S I I G
    Y   I   R
    之后从左往右，逐行读取字符："PAHNAPLSIIGYIR"
    实现一个将字符串进行指定行数变换的函数:
    string convert(string s, int numRows);

    示例 1:
    输入: s = "PAYPALISHIRING", numRows = 3
    输出: "PAHNAPLSIIGYIR"

    示例 2:
    输入: s = "PAYPALISHIRING", numRows = 4
    输出: "PINALSIGYAHRPI"
    解释:

    P     I    N
    A   L S  I G
    Y A   H R
    P     I

7   反转整数 -- 中等
    给定一个 32 位有符号整数，将整数中的数字进行反转。
        示例 1:
        输入: 123
        输出: 321

        示例 2:
        输入: -123
        输出: -321

        示例 3:
        输入: 120
        输出: 21

8   字符串转整数 (atoi) -- 中等
    实现 atoi，将字符串转为整数。
    在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
    字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。
    当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。
    若函数不能执行有效的转换，返回 0。
    说明：
    假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。如果数值超过可表示的范围，则返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

        示例 1:
        输入: "42"
        输出: 42

        示例 2:
        输入: "   -42"
        输出: -42
        解释: 第一个非空白字符为 '-', 它是一个负号。
             我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。

        示例 3:
        输入: "4193 with words"
        输出: 4193
        解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。

        示例 4:
        输入: "words and 987"
        输出: 0
        解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
             因此无法执行有效的转换。

        示例 5:
        输入: "-91283472332"
        输出: -2147483648
        解释: 数字 "-91283472332" 超过 32 位有符号整数范围。
             因此返回 INT_MIN (−231) 。

9   回文数 -- 简单
    判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
        示例 1:
        输入: 121
        输出: true

        示例 2:
        输入: -121
        输出: false
        解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

        示例 3:
        输入: 10
        输出: false
        解释: 从右向左读, 为 01 。因此它不是一个回文数。

10  正则表达式匹配 -- 中等
    给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。
    '.' 匹配任意单个字符。
    '*' 匹配零个或多个前面的元素。
    匹配应该覆盖整个字符串 (s) ，而不是部分字符串。
    说明:
    s 可能为空，且只包含从 a-z 的小写字母。
    p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

        示例 1:
        输入:
        s = "aa"
        p = "a"
        输出: false
        解释: "a" 无法匹配 "aa" 整个字符串。

        示例 2:
        输入:
        s = "aa"
        p = "a*"
        输出: true
        解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。

        示例 3:
        输入:
        s = "ab"
        p = ".*"
        输出: true
        解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。

        示例 4:
        输入:
        s = "aab"
        p = "c*a*b"
        输出: true
        解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。

        示例 5:
        输入:
        s = "mississippi"
        p = "mis*is*p*."
        输出: false